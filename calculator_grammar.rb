# Autogenerated from a Treetop grammar. Edits may be lost.


module CalculatorGrammar
  include Treetop::Runtime

  def root
    @root ||= :main
  end

  module Main0
    def new_line
      elements[0]
    end

    def statement
      elements[1]
    end
  end

  module Main1
    def set_all_parameters
      elements[0]
    end

    def tail
      elements[1]
    end
  end

  module Main2
    def value(context)
      (tail&.elements || []).inject([set_all_parameters.value]) do |l, elt| 
        parameters = elt.statement.value(context)
        parameters ? l << parameters : l
      end
    end
  end

  def _nt_main
    start_index = index
    if node_cache[:main].has_key?(index)
      cached = node_cache[:main][index]
      if cached
        node_cache[:main][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_set_all_parameters
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_new_line
        s3 << r4
        if r4
          r5 = _nt_statement
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Main0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Main1)
      r0.extend(Main2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:main][start_index] = r0

    r0
  end

  module SetAllParameters0
    def set_taux_percentage
      elements[0]
    end

    def set_taux_fix
      elements[4]
    end
  end

  module SetAllParameters1
    def set_taux_fix
      elements[0]
    end

    def set_taux_percentage
      elements[4]
    end
  end

  module SetAllParameters2
    def value
        set_taux_percentage.value.merge(set_taux_fix.value)
    end
  end

  def _nt_set_all_parameters
    start_index = index
    if node_cache[:set_all_parameters].has_key?(index)
      cached = node_cache[:set_all_parameters][index]
      if cached
        node_cache[:set_all_parameters][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_set_taux_percentage
    s1 << r2
    if r2
      s3, i3 = [], index
      loop do
        r4 = _nt_space
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s1 << r3
      if r3
        if (match_len = has_terminal?(",", false, index))
          r5 = true
          @index += match_len
        else
          terminal_parse_failure('","')
          r5 = nil
        end
        s1 << r5
        if r5
          s6, i6 = [], index
          loop do
            r7 = _nt_space
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s1 << r6
          if r6
            r8 = _nt_set_taux_fix
            s1 << r8
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(SetAllParameters0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
      r0.extend(SetAllParameters2)
      r0.extend(SetAllParameters2)
    else
      i9, s9 = index, []
      r10 = _nt_set_taux_fix
      s9 << r10
      if r10
        s11, i11 = [], index
        loop do
          r12 = _nt_space
          if r12
            s11 << r12
          else
            break
          end
        end
        r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
        s9 << r11
        if r11
          if (match_len = has_terminal?(",", false, index))
            r13 = true
            @index += match_len
          else
            terminal_parse_failure('","')
            r13 = nil
          end
          s9 << r13
          if r13
            s14, i14 = [], index
            loop do
              r15 = _nt_space
              if r15
                s14 << r15
              else
                break
              end
            end
            r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
            s9 << r14
            if r14
              r16 = _nt_set_taux_percentage
              s9 << r16
            end
          end
        end
      end
      if s9.last
        r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
        r9.extend(SetAllParameters1)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
        r0 = r9
        r0.extend(SetAllParameters2)
        r0.extend(SetAllParameters2)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:set_all_parameters][start_index] = r0

    r0
  end

  module SetTauxPercentage0
    def percentage
      elements[2]
    end
  end

  module SetTauxPercentage1
    def value
      { percentage: percentage.value }
    end
  end

  def _nt_set_taux_percentage
    start_index = index
    if node_cache[:set_taux_percentage].has_key?(index)
      cached = node_cache[:set_taux_percentage][index]
      if cached
        node_cache[:set_taux_percentage][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("TAUX=", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"TAUX="')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_percentage
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SetTauxPercentage0)
      r0.extend(SetTauxPercentage1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:set_taux_percentage][start_index] = r0

    r0
  end

  module SetTauxFix0
    def amount_euro
      elements[2]
    end
  end

  module SetTauxFix1
    def value
      { fix: amount_euro.value }
    end
  end

  def _nt_set_taux_fix
    start_index = index
    if node_cache[:set_taux_fix].has_key?(index)
      cached = node_cache[:set_taux_fix][index]
      if cached
        node_cache[:set_taux_fix][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("FIX=", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"FIX="')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_amount_euro
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SetTauxFix0)
      r0.extend(SetTauxFix1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:set_taux_fix][start_index] = r0

    r0
  end

  def _nt_statement
    start_index = index
    if node_cache[:statement].has_key?(index)
      cached = node_cache[:statement][index]
      if cached
        node_cache[:statement][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_statement_on_order

    node_cache[:statement][start_index] = r0

    r0
  end

  module StatementOnOrder0
    def condition
      elements[2]
    end

    def set_all_parameters
      elements[6]
    end
  end

  module StatementOnOrder1
    def value(context)
      set_all_parameters.value.merge(rule: "si #{condition.text_value}") if condition.value(context)
    end
  end

  def _nt_statement_on_order
    start_index = index
    if node_cache[:statement_on_order].has_key?(index)
      cached = node_cache[:statement_on_order][index]
      if cached
        node_cache[:statement_on_order][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("si", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"si"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_condition
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_space
            if r6
              s5 << r6
            else
              break
            end
          end
          if s5.empty?
            @index = i5
            r5 = nil
          else
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          end
          s0 << r5
          if r5
            if (match_len = has_terminal?("alors", false, index))
              r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('"alors"')
              r7 = nil
            end
            s0 << r7
            if r7
              s8, i8 = [], index
              loop do
                r9 = _nt_space
                if r9
                  s8 << r9
                else
                  break
                end
              end
              if s8.empty?
                @index = i8
                r8 = nil
              else
                r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              end
              s0 << r8
              if r8
                r10 = _nt_set_all_parameters
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(StatementOnOrder0)
      r0.extend(StatementOnOrder1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:statement_on_order][start_index] = r0

    r0
  end

  module Condition0
    def operator
      elements[1]
    end

    def predicate
      elements[3]
    end
  end

  module Condition1
    def predicate
      elements[0]
    end

    def tail
      elements[1]
    end
  end

  module Condition2
    def value(context)
      (tail&.elements || []).inject(predicate.value(context)) { |result, elt| 
        case elt.operator.text_value
          when "ou" then result || elt.predicate.value(context)
          when "et" then result && elt.predicate.value(context)
          else
            raise "Unexpected case #{elt.operator.text_value.inspect}"
        end
       }
    end
    def to_s
      "..."
    end
  end

  def _nt_condition
    start_index = index
    if node_cache[:condition].has_key?(index)
      cached = node_cache[:condition][index]
      if cached
        node_cache[:condition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_predicate
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        s4, i4 = [], index
        loop do
          r5 = _nt_space
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s3 << r4
        if r4
          i6 = index
          if (match_len = has_terminal?("ou", false, index))
            r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('"ou"')
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r6 = r7
          else
            if (match_len = has_terminal?("et", false, index))
              r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('"et"')
              r8 = nil
            end
            if r8
              r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
              r6 = r8
            else
              @index = i6
              r6 = nil
            end
          end
          s3 << r6
          if r6
            s9, i9 = [], index
            loop do
              r10 = _nt_space
              if r10
                s9 << r10
              else
                break
              end
            end
            if s9.empty?
              @index = i9
              r9 = nil
            else
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            end
            s3 << r9
            if r9
              r11 = _nt_predicate
              s3 << r11
            end
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Condition0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Condition1)
      r0.extend(Condition2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:condition][start_index] = r0

    r0
  end

  def _nt_logical_operator
    start_index = index
    if node_cache[:logical_operator].has_key?(index)
      cached = node_cache[:logical_operator][index]
      if cached
        node_cache[:logical_operator][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?("ou", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"ou"')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?("et", false, index))
        r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('"et"')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:logical_operator][start_index] = r0

    r0
  end

  def _nt_predicate
    start_index = index
    if node_cache[:predicate].has_key?(index)
      cached = node_cache[:predicate][index]
      if cached
        node_cache[:predicate][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_p_source
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_p_delivery
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_p_preparation_amount
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:predicate][start_index] = r0

    r0
  end

  module PSource0
    def source
      elements[3]
    end
  end

  module PSource1
    def source
      elements[2]
    end

    def tail
      elements[3]
    end
  end

  module PSource2
    def value(context)
      sources = (tail&.elements || []).inject([source.text_value]) { |s, elt| s << elt.source.text_value }
      sources.include?(context[:source])
    end
  end

  def _nt_p_source
    start_index = index
    if node_cache[:p_source].has_key?(index)
      cached = node_cache[:p_source][index]
      if cached
        node_cache[:p_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("la commande est issue de", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"la commande est issue de"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_source
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            i6, s6 = index, []
            s7, i7 = [], index
            loop do
              r8 = _nt_space
              if r8
                s7 << r8
              else
                break
              end
            end
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            s6 << r7
            if r7
              if (match_len = has_terminal?(",", false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r9 = nil
              end
              s6 << r9
              if r9
                s10, i10 = [], index
                loop do
                  r11 = _nt_space
                  if r11
                    s10 << r11
                  else
                    break
                  end
                end
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                s6 << r10
                if r10
                  r12 = _nt_source
                  s6 << r12
                end
              end
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(PSource0)
            else
              @index = i6
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PSource1)
      r0.extend(PSource2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:p_source][start_index] = r0

    r0
  end

  def _nt_source
    start_index = index
    if node_cache[:source].has_key?(index)
      cached = node_cache[:source][index]
      if cached
        node_cache[:source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?("APP", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"APP"')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?("WEB", false, index))
        r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('"WEB"')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:source][start_index] = r0

    r0
  end

  module PDelivery0
    def delivery
      elements[3]
    end
  end

  module PDelivery1
    def delivery
      elements[2]
    end

    def tail
      elements[3]
    end
  end

  module PDelivery2
    def value(context)
      deliveries = (tail&.elements || []).inject([delivery.text_value]) { |s, elt| s << elt.delivery.text_value }
      deliveries.include?(context[:delivery])
    end
  end

  def _nt_p_delivery
    start_index = index
    if node_cache[:p_delivery].has_key?(index)
      cached = node_cache[:p_delivery][index]
      if cached
        node_cache[:p_delivery][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("la livraison est", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"la livraison est"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_delivery
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            i6, s6 = index, []
            s7, i7 = [], index
            loop do
              r8 = _nt_space
              if r8
                s7 << r8
              else
                break
              end
            end
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            s6 << r7
            if r7
              if (match_len = has_terminal?(",", false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r9 = nil
              end
              s6 << r9
              if r9
                s10, i10 = [], index
                loop do
                  r11 = _nt_space
                  if r11
                    s10 << r11
                  else
                    break
                  end
                end
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                s6 << r10
                if r10
                  r12 = _nt_delivery
                  s6 << r12
                end
              end
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(PDelivery0)
            else
              @index = i6
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PDelivery1)
      r0.extend(PDelivery2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:p_delivery][start_index] = r0

    r0
  end

  def _nt_delivery
    start_index = index
    if node_cache[:delivery].has_key?(index)
      cached = node_cache[:delivery][index]
      if cached
        node_cache[:delivery][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?("CHRONO", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"CHRONO"')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?("PICKUP", false, index))
        r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('"PICKUP"')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:delivery][start_index] = r0

    r0
  end

  module PPreparationAmount0
    def amount_euro
      elements[2]
    end
  end

  module PPreparationAmount1
    def value(context)
      context[:preparation_amount_ttc] > amount_euro.value
    end
  end

  def _nt_p_preparation_amount
    start_index = index
    if node_cache[:p_preparation_amount].has_key?(index)
      cached = node_cache[:p_preparation_amount][index]
      if cached
        node_cache[:p_preparation_amount][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("le montant de la commande excede", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"le montant de la commande excede"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_amount_euro
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PPreparationAmount0)
      r0.extend(PPreparationAmount1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:p_preparation_amount][start_index] = r0

    r0
  end

  def _nt_new_line
    start_index = index
    if node_cache[:new_line].has_key?(index)
      cached = node_cache[:new_line][index]
      if cached
        node_cache[:new_line][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[\\n]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[\\n]')
      r0 = nil
    end

    node_cache[:new_line][start_index] = r0

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:space].has_key?(index)
      cached = node_cache[:space][index]
      if cached
        node_cache[:space][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[\\s]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[\\s]')
      r0 = nil
    end

    node_cache[:space][start_index] = r0

    r0
  end

  module Percentage0
    def x
      elements[0]
    end

  end

  module Percentage1
    def value() x.text_value.to_i end
  end

  def _nt_percentage
    start_index = index
    if node_cache[:percentage].has_key?(index)
      cached = node_cache[:percentage][index]
      if cached
        node_cache[:percentage][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
        r2 = true
        @index += 1
      else
        terminal_parse_failure('[\\d]')
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("%", false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('"%"')
        r3 = nil
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Percentage0)
      r0.extend(Percentage1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:percentage][start_index] = r0

    r0
  end

  module AmountEuro0
  end

  module AmountEuro1
    def x
      elements[0]
    end

  end

  module AmountEuro2
    def value() x.text_value.to_f end
  end

  def _nt_amount_euro
    start_index = index
    if node_cache[:amount_euro].has_key?(index)
      cached = node_cache[:amount_euro][index]
      if cached
        node_cache[:amount_euro][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1, s1 = index, []
    s2, i2 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
        r3 = true
        @index += 1
      else
        terminal_parse_failure('[\\d]')
        r3 = nil
      end
      if r3
        s2 << r3
      else
        break
      end
    end
    if s2.empty?
      @index = i2
      r2 = nil
    else
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
    end
    s1 << r2
    if r2
      if (match_len = has_terminal?(".", false, index))
        r4 = true
        @index += match_len
      else
        terminal_parse_failure('"."')
        r4 = nil
      end
      s1 << r4
      if r4
        if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
          r5 = true
          @index += 1
        else
          terminal_parse_failure('[\\d]')
          r5 = nil
        end
        s1 << r5
        if r5
          if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
            r6 = true
            @index += 1
          else
            terminal_parse_failure('[\\d]')
            r6 = nil
          end
          s1 << r6
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(AmountEuro0)
    else
      @index = i1
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("E", false, index))
        r7 = true
        @index += match_len
      else
        terminal_parse_failure('"E"')
        r7 = nil
      end
      s0 << r7
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(AmountEuro1)
      r0.extend(AmountEuro2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:amount_euro][start_index] = r0

    r0
  end

end

class CalculatorGrammarParser < Treetop::Runtime::CompiledParser
  include CalculatorGrammar
end
